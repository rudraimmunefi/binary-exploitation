Invoking Sys Calls with 0x80

EAX system call number
EBX 1st arg
ECX 2nd ARG
EDX 3rd arg
ESI 4th arg
EDI 5th arg

-------------------------------------

EAX Accumulator Register -- Used for storing operands and result data
EBX Base Register -- Pointer to data
ECX Counter Register -- Loop Operations
EDX Data Register -- I/O Pointer
ESI EDI  DATA POINTER registers for memory operations
ESP Stack Pointer Register
EBP Stack Data Pointer Register

---------------------------------------

Syscalls defined "/usr/include/i386-linux-gnu/asm/unistd_32.h"

---------------------------------------

FD 0 == STDIN
FD 1 ==  STDOUT

---------------------------------------

Count Number of characters in string

equ $-variable

-----------------------------------------

$ means start of the line while $$ means start of the section

--------------------------------

Little Edianess means that the starting byte gets stored in the higher memory and ending byte stored in the lower memory.

--------------------------------

Uninitialised data goes into bss section

---------------------------------

Define start of the program by using :

global _start 

Append _start: in .text section

------------------------------------------

To read available functions in binary use info functions in gdb

Or

readelf -h binary-name

------------------------------------------------

Examine Datatypes GDB

single byte - x/b &var1
3bytes - x/3b &var2
Word - x/2b &var3
Double word - x/[number]b &var4

-------------------

Access memory in NASM using []

mov al, [sample]
-------------------------------------------------

Multiplication 

8Bit - Multiplier 1 is set in AL and result is saved in AX 

16Bit- Mupltiplier 1 is set in AX register and result is saved in DX and AX combination

32Bit - Multiplier 1 is set in EAX and result is saved in EDX and EAX combination

OF (overflow) and CF (carry) is set when upper half of result is non-zero

-------------------------------------------

Division

8Bit - Divisor 1 is set in AX and Questiant is in AL and Remainder is in AH

16Bit - Divisor 1 is set in DX and AX , Q is in AX and R is in DX

32Bit - Divisor is in EDX and EAX , Q is in EAX and R is in EDX

---------------------------------------------------

& (bitwise AND) Takes two numbers as operands and does AND on every bit of two numbers. The result of AND is 1 only if both bits are 1.
| (bitwise OR) Takes two numbers as operands and does OR on every bit of two numbers. The result of OR is 1 if any of the two bits is 1.
^ (bitwise XOR) Takes two numbers as operands and does XOR on every bit of two numbers. The result of XOR is 1 if the two bits are different.
<< (left shift) Takes two numbers, left shifts the bits of the first operand, the second operand decides the number of places to shift.
>> (right shift) Takes two numbers, right shifts the bits of the first operand, the second operand decides the number of places to shift.
~ (bitwise NOT) Takes one number and inverts all bits of it

-----------------------------------------------------

If all the bit position in AND operation are same then the result would remain unchanged.

If all the bits porisition in AND operation are not alligned then the result would be 0.

If all the bit position in OR operation are same then the result would remain unchanged.

If all the bit position in XOR operation are same then the result would be 0.

XOR of any number with 0 with be the same number

--------------------------------------------------------------

The LOOP instruction assumes that the ECX register contains the loop count. When the loop instruction is executed, the ECX register is decremented and the control jumps to the target label

----------------------------------------------------------